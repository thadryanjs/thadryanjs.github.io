{
  "hash": "f99e85c68f8896f2ebde18879fea1b54",
  "result": {
    "markdown": "---\nauthor: \"Thadryan\"\ntitle: \"zip and dict\"\ndate: \"2017-12-20\"\ndescription: \"The peanutbetter and jelly of paired data.\"\ncategories:\n  - Perl\n  - Python\n---\n\n# The peanut-butter and jelly of paired data: zip() and dict()\n\nPaired data in Python is user-friendly and efficient, and I find myself using it all the time. Sometimes in the course of a workflow, we end up with with multiple simple lists of information that would be easier managed as paired data. If you find yourself in this situation, there are two simple tools that work in a really intuitive way to â€œzipâ€ the lists together such that the first item of list A is paired with the first item of list B. If the lists were [â€œBruceâ€, â€œPeterâ€] and [â€œWayneâ€, â€œPakerâ€] the out put would match them to {â€œBruceâ€:â€Wayneâ€, â€œPeterâ€:â€Parkerâ€}. *note that Python will also accept {â€œMilesâ€:â€Moralesâ€} ğŸ™‚\n\nLet's say we have two lists of names and want to store them as paired data in a dictionary. All we need to do to get a nice, tidy, dictionary out of it is the following (I'll show the running code and then go through it afterwards with a more realistic use case).\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# here are our two lists\nfirst = [\"A\",\"B\",\"C\"]\nsecond = [\"1\",\"2\",\"3\"]\n\n# make a dict from the output of zipping the two iterables\nthird = dict(zip(first, second))\n\n# iterate thorough and show we got what we were looking for\nfor item in third:\n    print(item, third[item])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA 1\nB 2\nC 3\n```\n:::\n:::\n\n\nThat's it. What's going on here? Let's take a closer look.\n\nPython has a \"zip\" function that will return a zip object of tuples (don't worry if that sounds weird; it just means it is a zip class and has our data stored in a way such that it can't be modified). It takes iteratable objects like lists as arguments, in our case, just two. It goes through the lists in order, and \"zips\" them together, first item to first item, second to second, and so on.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# here are our to lists\nfirst = [\"Christopher\",\"Jo-Vaughn\",\"Sean\",\"Sir Robert Bryson\"]\nlast = [\"Wallace\",\"Scott\",\"Carter\",\"Hall II\"]\n\n# call the zip function that takes iteratable structure \nnames = zip(first, last)\n\n# if we print it out, we see we have a zip object and memory address\nprint(names)\nprint(type(names))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<zip object at 0x7fabf4765600>\n<class 'zip'>\n```\n:::\n:::\n\n\nWhile they are in the object, we can't use them as paired data directly. Fortunately, the dict() function will take a list of tuples and return a dictionary.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# use the dict function on the zip object\nnames = dict(names)\n\n# print out the evidence\nfor item in names:\n    print(item, names[item])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nChristopher Wallace\nJo-Vaughn Scott\nSean Carter\nSir Robert Bryson Hall II\n```\n:::\n:::\n\n\nNote that this will also work with ints and floats. That's all there is to it. Thanks for reading.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}