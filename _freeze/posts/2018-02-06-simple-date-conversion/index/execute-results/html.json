{
  "hash": "23032984107f2b73f265c4765020d175",
  "result": {
    "markdown": "---\nauthor: \"Thadryan\"\ntitle: \"Simple date-string conversion\"\ndate: \"2018-02-06\"\ndescription: \"Answering a question an dates and strings.\"\n---\n\n# Simple Date Strings Conversion: split-process-joinÂ¶\nSomeone recently asked me about converting dates in number form to dates their names to make approximate ranges that are easier to read. For example, \"01/01/2017 to 04/01/2017\" would be \"January to February\" (in the context of what I was being asked, the years were the columns in a dataframe, so I wasn't concerned with the year.\n\nFirstly, when confronted with this type of challenge, it is best to do a little background reading. If the times are in a certain format, for instance, there might be packages that allow you to manipulate and convert them already written, like Python's datetime module. For this post, we will just assume we have raw strings and have to deal with them.\n\nThat said, let's see what we are dealing with.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndate = \"01/01/2017 to 04/01/2017\"\n```\n:::\n\n\nNote that the information is all in one string, as opposed to a list with the dates in their own entries.\n\nThe first thing that might come to mind is a regular expression. They're a powerful tool, and they might be useful in a problem like this. I ended finding a way to it without them. In general, I try to avoid them for simple tasks because trying to add a regex to a program is like busting out your pepper spray in a mosh pit. Quick, easy, life saver? Spark that turns a dicey situation into a full-on incident? Well-intended plan that backfires causing hours of pain? You just don't know.\n\nI used a \"split-process-join\" approach.\n\nIn order to simplify the process, I split the string on \" to \" so we can deal with each date on its own.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# use the split function \nsplit_date = date.split(\" to \")\n\nprint(split_date)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['01/01/2017', '04/01/2017']\n```\n:::\n:::\n\n\nNow we an iterate over the list and use the .startswith() with method as this is a list of strings. I use the the range() function instead of \"for x in y\" because we want to refer to list elements by their number.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# for each index in length of list...\nfor i in range(len(split_date)):\n    \n    # give it a name to for readability\n    entry = split_date[i]\n    \n    # if the entry there starts with \"01/\" -> \"January\"\n    if entry.startswith(\"01/\"):\n        \n        # replace the item in the array with the month\n        split_date[i] = \"January\"\n        \n    # as above with \"February\"\n    if entry.startswith(\"04/\"):\n       \n        # put \"February\" there\n        split_date[i] = \"February\"\n        \n# see the output \nprint(split_date)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['January', 'February']\n```\n:::\n:::\n\n\n To finish the process, we simply need to join the entries back on the \" to \". Because .split() and .join() and string methods in Python, the join is admittedly awkward looking.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# on \" to \" join split_date\nfinal = \" to \".join(split_date)\n\n# show results \nprint(final)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJanuary to February\n```\n:::\n:::\n\n\nAnd we're there:) All in once place, and from the top, that gives us:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndate = \"01/01/2017 to 04/01/2017\"\n\nsplit_date = date.split(\" to \")\n\nfor i in range(len(split_date)):\n    entry = split_date[i]\n    if entry.startswith(\"01/\"):\n        split_date[i] = \"January\"\n    if entry.startswith(\"04/\"):\n        split_date[i] = \"February\"\n\nfinal = \" to \".join(split_date)\n\nprint(final)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJanuary to February\n```\n:::\n:::\n\n\nObviously, this is just a proof of concept that only works for two months, but it is easy to see how it could made into a function. What would your next step be? I'd go with a function using a dict.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef number_to_name(date):\n    # create a dic that stores the pairs\n    d = {\"01/\":\"January\",  \"02/\":\"February\", \"03/\":\"March\", \n         \"04/\":\"April\"  ,  \"05/\":\"May\",      \"06/\":\"June\",\n         \"07/\":\"July\",     \"08/\":\"August\",   \"09/\":\"September\",\n         \"10/\":\"October\",  \"11/\":\"November\", \"12/\":\"December\" }\n    \n    split_date = date.split(\" to \")\n    for i in range(len(split_date)):\n        entry = split_date[i]\n        # the first 3 chars denote the month\n        month = entry[:3]\n        # sub them from dict\n        split_date[i] = d[month]\n    # return after joining \n    return \" to \".join(split_date)               # ugly, but saves a line\n                                         \nprint(number_to_name(\"01/01/2017 to 04/01/2017\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJanuary to April\n```\n:::\n:::\n\n\nIt might make sense to define the dict outside the function so it doesn't recreate it every time in practice. Feel free to take this and do whatever to it, and I am open to hearing how people would improve it.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}