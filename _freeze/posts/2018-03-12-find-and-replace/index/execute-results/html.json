{
  "hash": "729abc824931e1c33a094e84d5e152c1",
  "result": {
    "markdown": "---\nauthor: \"Thadryan\"\ntitle: \"Find and replace in Python\"\ndate: \"2018-03-12\"\ndescription: \"Like ctrl-f with for Python.\"\ncategories:\n  - Python\n  - Data Processing\n---\n\nUsing a dict to perform find and replace tasks makes a lot of sense; they're simple to implement and they allow us to easily store the target with our desired replacement in one spot. There are a few hidden traps to keep be aware of, but they're easily avoided and we can be back on track reaping the benefits with just a little forethought.\n\n# Find and Replace Deluxe:\n\n## How to use a Python dict for find/replace functions\nWe're going to go through several examples of find-and-replace tasks of varying complexity. We'll also find some potential hiccups and how to avoid them. We're going to use a simple string that is a coherent message if the code works and is hard to read if it isn't to see if our efforts are working.\n\n## Simple character-character substitution\nReplacing one character with another is pretty straightforward using a function. This function takes the string and the dict as arguments, iterates through them, and makes the replacements. You'll notice it has an \"if\" statement. This is to make sure that the item exists in our dict or else we get a keyError. We can't replace something will the right pair in the dict if the item isn't in the dict, and, if you think about it, that's what we're trying to do if we iterate over every letter and look it up in the dict regardless of whether or not it's there.\n\nNote: I'm going to comment every line on this one to make sure we're on the same page as this function will serve as the basis of all the ones coming after it. After that, I'll just highlight what is different about the function.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# here is our target string, contaminated with \"X\"s\ns = \"HEREXISXAXSAMPLEXSTRING\"\n\n# dictionary pairs \"X\" with \"-\"\nd = {\"X\":\"-\"}\n\n# define a functions that takes a string and a dict\ndef find_replace(string, dictionary):\n    # is the item in the dict?\n    for item in string:\n        # iterate by keys\n        if item in dictionary.keys():\n            # look up and replace\n            string = string.replace(item, dictionary[item])\n    # return updated string\n    return string\n\n# call the funciton\nfind_replace(s,d)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n'HERE-IS-A-SAMPLE-STRING'\n```\n:::\n:::\n\n\nWe can see that all the \"X\"s have been replaced by \"-\", their paired value.\n\n## Replacing multi-character values\n\nThis follows the same basic pattern, but uses a simple regex function. We will get rid of \"ABC\"s instead of \"X\"s. We import the re library and modify our string and dict for the test.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport re\n\ns = \"HEREABCISABCAABCSAMPLEABCSTRING\"\n\nd = {\"ABC\":\"-\"}\n\ndef find_replace_multi(string, dictionary):\n    for item in dictionary.keys():\n        # sub item for item's paired value in string\n        string = re.sub(item, dictionary[item], string)\n    return string\n\nfind_replace_multi(s, d)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n'HERE-IS-A-SAMPLE-STRING'\n```\n:::\n:::\n\n\n## Replacing single and multi character patterns...oh wait, crap...\n\nThere is a final kink in this however. What would happen if one of the single character values we wanted to replace occurs within the multi-character string?\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# the middle \"ABC\" has been replaced with just an \"C\"\ns = \"HEREABCISABCACSAMPLEABCSTRING\"\n\n# ...which we see \nfind_replace_multi(s,d)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n'HERE-IS-ACSAMPLE-STRING'\n```\n:::\n:::\n\n\nAlas! It seems we have a variation. We assumed all the problematic strings were \"ABC\"s, but one is just a \"C\". No problem, right? We just update the dictionary to get rid of \"C\" as well. Not quite. Here is the thing that goes wrong with these types of functions: we don't know what order the substitutions are happening in. So we might remove the \"C\" from \"ABC\" (leaving it as just \"AB\") first thing, then when we look for \"ABC\"s to sub, there wont be any. Our program would end without doing anything, and we would still have the \"AB\".\n\nFor another example, imagine we are replacing \"Hello\" with 1, and \"He\" with 2. Our string could be \"He Said Hello\". If \"He\" gets changed first, we would have \"2 Said 2llo\". When we go to look for hello? There is no hello.\n\n## So what do we do?\n\nMy solution for this problem is to make sure we iterate through the dictionary keys from LARGEST by length to SMALLEST by length to ensure that we don't replace any pieces of them by accident. Using the He/Hello example, we substitute the \"Hello\" first so none of the substrings (\"He\") can interfere. We can do this by using the sorted() function and using the reverse = True options (it goes smallest to largest by default). Check it.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ns = \"HEREABCISABCACSAMPLEABCSTRING\"\n\nd ={\"C\":\"-\", \"ABC\":\"-\"}\n\ndef find_replace_multi_ordered(string, dictionary):\n    # sort keys by length, in reverse order\n    for item in sorted(dictionary.keys(), key = len, reverse = True):\n        string = re.sub(item, dictionary[item], string)\n    return string\n\nfind_replace_multi_ordered(s, d)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n'HERE-IS-A-SAMPLE-STRING'\n```\n:::\n:::\n\n\nLooks as if we are on the right track. Because we replaced the biggest strings first (\"ABC\"), and the the smallest (\"C\"), we ensure the \"C\" in \"ABC\" didn't get messed with. I'll write one more test to be sure. To confirm that the largest is going first, and not simply that \"ABC\" is going before \"C\", we'll add another value to the dict (the rest of the code stays the same). I'll use \"CSAMPLEABC\", because the only way for that to be replaced is if it goes before \"C\" and \"ABC\" as BOTH of those strings are in it.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ns = \"HEREABCISABCACSAMPLEABCSTRING\"\n\nd ={\"C\":\"-\", \"ABC\":\"-\", \"CSAMPLEABC\":\"-:)-\"}\n\ndef find_replace_multi_ordered(string, dictionary):\n    # sort keys by length, in reverse order\n    for item in sorted(dictionary.keys(), key = len, reverse = True):\n        string = re.sub(item, dictionary[item], string)\n    return string\n\nfind_replace_multi_ordered(s, d)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n'HERE-IS-A-:)-STRING'\n```\n:::\n:::\n\n\nAnd there we have it! Our final function. It's worth noting that, while I made the initial character-character find-and-replace function to work us up to this one, we final function will work for simple character-character substitutions too, so we only need the one, final version for all the tasks here. I'd advise doing so because it has error avoidance with the iteration and the \"if\" statement.\n\n<!-- ## If you're the type to stick around after the credits... -->\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}