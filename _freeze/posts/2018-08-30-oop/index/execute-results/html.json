{
  "hash": "e9ab681c0c75dfc539a49725a88e099d",
  "result": {
    "markdown": "---\nauthor: \"Thadryan\"\ntitle: \"Object-oriented Python: an overview\"\ndate: \"2018-08-30\"\ndescription: \"An overview of object-oriented programming in Python.\"\n---\n\nObject-Oriented Programming is a huge topic, and a unit dedicated to it has been in the queue for PyWy for some time. In the mean time, here is a crash course to give you an idea of what to expect!\n\n## Object Oriented Programming (OOP)\n\nOOP is often considered a little weird to learn, but becomes very intuitive with some practice because it is used to model real things. It's used to imitate things from the real world and store data in the same way they do.\n\nA \"class\" is a model or blueprint for how to store that information. You might have a class to imitate \"Students\". Each INDIVIDUAL occurrence of a class is called and \"object\". If there was a class called \"Student\", you and I were students, we would be individual objects of the type \"Student\". In Python code this looks like this:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# class \"Student\" is an object\nclass Student(object):\n    # def is Python's version of sub - we're making a function acting on self                 \n    def say_what_you_are(self):          \n        # print out a message \n        print(\"I am a student\")          \n```\n:::\n\n\n## Initialization\n\nThis is simply a way to say \"creation\". We've described to the computer how to make a Student, but keep in mind we didn't actually tell it to do so. We just told it HOW to do so. It's the blueprint NOT a building.\n\nNow let's make an individual object:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nJiaojiao = Student() # Python doesn't require you to say new\n```\n:::\n\n\nThat's it. Notice that there is no output. She's just sitting there. That's ok. We told her to be born as a student, we didn't tell her to do anything. Unless otherwise specified, an object will just sit there, existing. Let's make her do something:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nJiaojiao.say_what_you_are()    # the \".\" notation is used to \"call\" things out of or from an object. \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI am a student\n```\n:::\n:::\n\n\nThat's all this student class can do. Not very interesting. We will write over thr first definition with a better one. Let's add an attribute:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nclass Student(object):\n    # we've added an attribute \"name\", that starts blank\n    name = \"\" \n    def say_what_you_are(self):\n        print(\"I am a student\")\n```\n:::\n\n\nNow \"Student\"s have a name, set to nothing by default. Let's see how we would use that:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# create Ashmi \nAshmi = Student()         \n\n# Will print an empty string. Not helpful!\nprint(Ashmi.name)         \n\n# give her a name, because it starts as nothing. No (), because its not a function/method\nAshmi.name = \"Ashmmi\"    \n\n# we can print her name now\nprint(Ashmi.name)         \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nAshmmi\n```\n:::\n:::\n\n\nLet's make the class more usefull by adding an introduce itself. This requires us to understand \"self\" more. \"self\" is to explicity tell the object what to do and let it know it's talking about itself. It's as if you pass it to itself so it can do things to itself, like how Perl has \"$self = shift\". It's \"self\" aware, in that it can get to it's attibutes. This is a really powerful idea becaues it allows us to direct lots of objects with making each one.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nclass Student(object):\n\n    name = \"\"\n    \n    # let it know who it will be talking about.\n    def say_what_you_are(self):    \n        print(\"I am a student\")\n\n    # acces the name of self\n    def introduce_yourself(self):         \n        print(\"Hello, I am\", self.name)   \n```\n:::\n\n\nHere is how we can use this and the objects will say their specific name.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nNareh = Student()\nNareh.name = \"Nareh\"\n\nAshmi = Student()\nAshmi.name = \"Ashmi\"\n\n# they will give their names with the same method call\nNareh.introduce_yourself()     \nAshmi.introduce_yourself()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, I am Nareh\nHello, I am Ashmi\n```\n:::\n:::\n\n\n## Contructor/Initializer/BUILD\n\nYou make have noticed that it's annoying to specify the name after the object is created. We can make this automatic with a \"contructor\" or \"initializer\", a special function that triggers automatically whenever an object is initialized. in Perl/Moose this is called BUILD. In Python it's called \"__init__\" to differentiate it form other functions. We will add one. It will take an argument, like any other function might and use it to set the attributes of the class.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nclass Student(object):\n    \n    # name is nothing, but will be set by __init__ (BUILD)\n    name = \"\"                   # <-------\n    \n    # define __init__ that acts on \"self\", and takes a \"name\"\n    def __init__(self, name):   \n        self.name = name        \n           \n    # set your name attribute (above) to the name that is given to you \n    def say_what_you_are(self):\n        print(\"I am a student\")\n        \n    def introduce_yourself(self):\n        print(\"Hello, I am\", self.name) \n```\n:::\n\n\nNow we can have behavior for the object from the moment it is created. This is super powerfull because we can give them some instructions and they will get along without us.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# now we can just give the name from the start and don't have to mess with the object\nNareh = Student(\"Nareh\")    \nAshmi = Student(\"Ashmi\")  \n\nNareh.introduce_yourself()\nAshmi.introduce_yourself()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, I am Nareh\nHello, I am Ashmi\n```\n:::\n:::\n\n\n## Inheritance\n\nSometimes it is usefull to have sub catagories that a variations on the same type. This is a fancy word that, fortunately, means the same thing in OPP as it does in te regular world. An new class of objects can \"inherit\" attribues from an ancestor called a \"base class\". Let's see if there would a way to use this for Student. There are different types of students that share similar traits. We will start with something simple.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nclass Student(object):\n    def go_on_coop(self):\n        print(\"I will find a coop!\")\n\nJohn = Student()\nJohn.go_on_coop()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI will find a coop!\n```\n:::\n:::\n\n\nNothing new here yet. But now we'll make a subclass of Student calles a MastersStudent that does more specific things than a general Student. It will automatically get things that a student has because we will pass the \"Student\" class to its definition not just any generic object.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# notice we pass in Student not object!!!!!!!\nclass GradStudent(Student):               \n    # something more specific \n    def complain_about_undergrads(self):\n        print(\"Stupid undergrads!\")\n```\n:::\n\n\nLet's make an MS student:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# make a MastersStudent\nSara = GradStudent()          \n# we know she can complain about undergrads because we coded that above\nSara.complain_about_undergrads() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStupid undergrads!\n```\n:::\n:::\n\n\nWe're not suprised when we see she can use complain_about_undergrads() because we specifically told her how. But guess what else Sara can do:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# she \"inherited\" this from the generic Student class\nSara.go_on_coop()     \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI will find a coop!\n```\n:::\n:::\n\n\nSarah can use the methods from both classes becaues she is from MastersStudent that inherits things from regular Student. If we had written \"class MastersStudent(object):\", it would still make a class, but not one that had access to things that Student does.\n\n## Multiple Inheritance\n\nWe don't have to stop there. Let's get a level more specific.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# a PhD Student is a type of MastersStudnet, not just any Student\nclass PhdStudent(GradStudent):\n    # they write dissertations (theortically)\n    def write_dissertation(self):     \n        print(\"Write, write, write!\")\n```\n:::\n\n\nPhD Student gets \"complain_about_undergrads()\" from \"GradStudent\", but it also gets \"go_on_coop()\" from GradStudent because GradStudnet gets it from Student!\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# make a PhdStudent\nChuck = PhdStudent()                  \n# look a all the shit I can do!\nChuck.go_on_coop()\n# even though you didn't have to tell me in my class\nChuck.complain_about_undergrads()    \nChuck.write_dissertation()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI will find a coop!\nStupid undergrads!\nWrite, write, write!\n```\n:::\n:::\n\n\nIf we really wanted to go nuts, we could add another level:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nclass PostDoc(PhdStudent):\n    def moar_phd_type_stuff(self):\n        print(\"What the hell is wrong with me?\")\n        \nMurillo = PostDoc()\n# can do ALL OF IT!!!\nMurillo.go_on_coop()\nMurillo.complain_about_undergrads()\nMurillo.write_dissertation()\nMurillo.moar_phd_type_stuff()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI will find a coop!\nStupid undergrads!\nWrite, write, write!\nWhat the hell is wrong with me?\n```\n:::\n:::\n\n\nThis saves us a lot of repetitive writing. But what if we wanted the tree to fork?\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n### a class of masters student based on student \nclass MastersStudent(Student):\n    # MastersStudent - they're still based on Student\n    def panic_about_life(self):    \n        print(\"I should have just done a Phd\")\n\n\n### a class of PhD student based on student \n# PhdStudent - they're still based on Student\nclass PhdStudent(Student):            \n    def panic_about_life(self):\n        print(\"I should have stopped at my Master's\")\n```\n:::\n\n\nNow these different types of subtypes will both share all the things that Student has, but the will have slightly different behavior when it is time to panic(). Observe:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# make a MastersStudent\none_version_of_somone = MastersStudent()    \n# call the methods \none_version_of_somone.go_on_coop()         \none_version_of_somone.panic_about_life()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI will find a coop!\nI should have just done a Phd\n```\n:::\n:::\n\n\nSame thing but with a PhD:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# make a PhdStudent\nother_version_of_somone = PhdStudent()      \n # will be the same\nother_version_of_somone.go_on_coop()\n# will be DIFFERENT!\nother_version_of_somone.panic_about_life()  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI will find a coop!\nI should have stopped at my Master's\n```\n:::\n:::\n\n\nNotice how they both can go on co-op and it is the same, but when they use panic because we redefined it.\n\nHere is another good example of \"Polymorphic\" behavior:\n\nhttps://stackoverflow.com/questions/3724110/practical-example-of-polymorphism\n\n## Composition/Traits\n\nSometimes we want to mix and match traits without inheriting all of them. It make sense in one context for a class called \"BiologicalLifeForm\" pass on traits like \"Eat\", \"Breathe\", and \"Reproduce\". But if you had an Animals class and wanted to make \"Birds\" and \"Dogs\", it wouldn't make sense to have dogs that had the \"Fly\" attribute.\n\nTo keep it in our student example, suppose we didn't want our PhD students to complain about undergrads anymore because they have to give lectures with them, but still let our MS students do it. We could make a \"complainer\" trait and give it to the MS students but not the PhDs. Perl calls these \"roles\". Most OOP systems call them \"traits\". Python doesn't have traits per se, you often just make another small class and \"mix\" it together with other ones to get what you want. For our purposes, We can make each \"trait\" into it's own class and pick only what we want.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n### here is a \"trait\"\nclass GradStudent(object):\n    # a class of a grad student that will be the GradStudent \"trait\"\n    def do_things(self):\n        print(\"I study!\")\n        \n### here is the other \nclass Complainer(object):         \n    # a class of a complainer that will be the complainer \"trait\"\n    def complain_about_undergrads(self):\n        print(\"Seriously, they are the WORST\")\n```\n:::\n\n\nLet's mix and match! We'll make a class the has one trait, and another that has both.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n### a class \"composed\" of one trait\nclass PhdStudent(GradStudent):  \n    # PhdStudents are GradStudents - we add \"mix in\" one trait to make the class\n    def say_hi(self):    \n        print(\"I am a PhD student. I can't kvetch about undergrads. That makes no sense.\")\n        \n### a class \"composed\" of two traits - GradStudent and Complainer  \nclass MastersStudent(GradStudent, Complainer): \n    # Masters Students are GradStudents AND Complainers\n    # # we wix in two traits to make the class\n    def say_hi(self):\n        \n        print(\"I am a MS student, I CAN kvetch about undergrads. Watch:\")\n```\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# make a MastersStudent\nus = MastersStudent()            \n# use their traits \nus.say_hi()                      \nus.complain_about_undergrads()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI am a MS student, I CAN kvetch about undergrads. Watch:\nSeriously, they are the WORST\n```\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# make a PhdStudent\nthem = PhdStudent()               \n# will work\nthem.say_hi()\n# will not if uncommented - didn't get composed with complain_about_undergrads()\n# them.complain_about_undergrads() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI am a PhD student. I can't kvetch about undergrads. That makes no sense.\n```\n:::\n:::\n\n\nIt's a little abstract in theory, but very useful in practice. It's where design comes in - it's not always clear which is best, or both might be just fine. Gotta tinker. It's just odd because it requires to look at coding in abstraction not just technique. For more examples, imagine you were modeling the characters in a story. I might make three traits:\n\nLover\n\nFighter\n\nAsshole\n\nThe Hero of the story could be a Lover + Fighter. The Villian of the story would be a Fighter + Asshole. That way you could keep a trait from going where you don't want it. A less abstract example would be in something like our final. You could make traits like:\n\nReader\n\nWriter\n\nGenerator\n\nDisplayer\n\nObjects that read in sequence data and made new subseq objects might have the traits \"Reader\" and \"Generator\", and have the _getGenbankSeqs method. The ones that wrote new fasta files might be \"Writer\" and have writeFasta. You could add \"Displayer\" to whatever one you wanted to see terminal output from (it would probably have printResults).\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}